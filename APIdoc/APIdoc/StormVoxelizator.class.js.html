<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>StormEngineC 1.2 API DOC Source: StormVoxelizator.class.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.stormenginec.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">StormEngineC 1.2 API DOC</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="ActionHelpers.html">ActionHelpers</a>
						</li>
						
						<li>
							<a href="StormBufferObject.html">StormBufferObject</a>
						</li>
						
						<li>
							<a href="StormCamera.html">StormCamera</a>
						</li>
						
						<li>
							<a href="StormControllerFollow.html">StormControllerFollow</a>
						</li>
						
						<li>
							<a href="StormControllerPlayer.html">StormControllerPlayer</a>
						</li>
						
						<li>
							<a href="StormControllerPlayerCar.html">StormControllerPlayerCar</a>
						</li>
						
						<li>
							<a href="StormControllerTargetCam.html">StormControllerTargetCam</a>
						</li>
						
						<li>
							<a href="StormEngineC.html">StormEngineC</a>
						</li>
						
						<li>
							<a href="StormEngineC_PanelAnimationTimeline.html">StormEngineC_PanelAnimationTimeline</a>
						</li>
						
						<li>
							<a href="StormForceField.html">StormForceField</a>
						</li>
						
						<li>
							<a href="StormGI.html">StormGI</a>
						</li>
						
						<li>
							<a href="StormGLContext.html">StormGLContext</a>
						</li>
						
						<li>
							<a href="StormGraph.html">StormGraph</a>
						</li>
						
						<li>
							<a href="StormGrid.html">StormGrid</a>
						</li>
						
						<li>
							<a href="StormGroupNodes.html">StormGroupNodes</a>
						</li>
						
						<li>
							<a href="StormLight.html">StormLight</a>
						</li>
						
						<li>
							<a href="StormLine.html">StormLine</a>
						</li>
						
						<li>
							<a href="StormLineSceneCollision.html">StormLineSceneCollision</a>
						</li>
						
						<li>
							<a href="StormM16.html">StormM16</a>
						</li>
						
						<li>
							<a href="StormMaterial.html">StormMaterial</a>
						</li>
						
						<li>
							<a href="StormNode.html">StormNode</a>
						</li>
						
						<li>
							<a href="StormPolarityPoint.html">StormPolarityPoint</a>
						</li>
						
						<li>
							<a href="StormTriangleBox.html">StormTriangleBox</a>
						</li>
						
						<li>
							<a href="StormUtils.html">StormUtils</a>
						</li>
						
						<li>
							<a href="StormV3.html">StormV3</a>
						</li>
						
						<li>
							<a href="StormVoxelizator.html">StormVoxelizator</a>
						</li>
						
						<li>
							<a href="WebCLGL.html">WebCLGL</a>
						</li>
						
						<li>
							<a href="WebCLGLBuffer.html">WebCLGLBuffer</a>
						</li>
						
						<li>
							<a href="WebCLGLBufferItem.html">WebCLGLBufferItem</a>
						</li>
						
						<li>
							<a href="WebCLGLKernel.html">WebCLGLKernel</a>
						</li>
						
						<li>
							<a href="WebCLGLKernelProgram.html">WebCLGLKernelProgram</a>
						</li>
						
						<li>
							<a href="WebCLGLUtils.html">WebCLGLUtils</a>
						</li>
						
						<li>
							<a href="WebCLGLVertexFragmentProgram.html">WebCLGLVertexFragmentProgram</a>
						</li>
						
						<li>
							<a href="WebCLGLWork.html">WebCLGLWork</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#$M16">$M16</a>
						</li>
						
						<li>
							<a href="global.html#$V3">$V3</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: StormVoxelizator.class.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">/**
* @class
* @constructor
*/
StormVoxelizator = function(sec) {
	this._sec = sec;
	
	this.idNum;
	this.name;
	this.objectType = 'voxelizator'; 
	this.CLGL_Voxels; // WebCLGL object
	
	this.clglBuff_VoxelsColor;  // 
	this.clglBuff_VoxelsPositionX;
	this.clglBuff_VoxelsPositionY;
	this.clglBuff_VoxelsPositionZ;
	this.clglBuff_VoxelsNormal;
	
	this.image3D_VoxelsColor; 
	this.image3D_VoxelsPositionX; 
	this.image3D_VoxelsPositionY; 
	this.image3D_VoxelsPositionZ; 
	this.image3D_VoxelsNormal; 
	
	this.rayTraversalInitSTR;
	this.rayTraversalSTR;
	this.size = 2.1; // grid size (one axis)
	this.resolution = 32;// grid resolution (one axis)
	this.cs;// cell size
	this.chs;// cell half size
	this.wh;// 3dtexture resolution (one axis)
	
	this.ongeneratefunction; 
	
	
	// generateFromScene variables
	this.canvas = document.createElement('canvas');
	this.canvas.style.border = "1px solid #FFF";
	this.glVoxelizator;
	this.BOS = []; // Array StormBufferObjects
	this.MATS = []; // Array StormMaterials
	this.arr_VoxelsColor; // 3dtexture
	this.arr_VoxelsPositionX; // 3dtexture
	this.arr_VoxelsPositionY; // 3dtexture
	this.arr_VoxelsPositionZ; // 3dtexture
	this.arr_VoxelsNormal; // 3dtexture
};
/** @private */
StormVoxelizator.prototype.initShader_VoxelizatorMaker = function() {
	this.canvas.width = this.resolution;
	this.canvas.height = this.resolution;
	this.glVoxelizator = this._sec.utils.getWebGLContextFromCanvas(this.canvas, {antialias: false});
	
	var highPrecisionSupport = this.glVoxelizator.getShaderPrecisionFormat(this.glVoxelizator.FRAGMENT_SHADER, this.glVoxelizator.HIGH_FLOAT);
	this.precision = (highPrecisionSupport.precision != 0) ? 'precision highp float;\n\nprecision highp int;\n\n' : 'precision lowp float;\n\nprecision lowp int;\n\n';
	
	var mesh = new StormMesh(this._sec);
	mesh.loadQuad(undefined,1.0,1.0);
	this.vertexBuffer_QUAD = this.glVoxelizator.createBuffer();
	this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, this.vertexBuffer_QUAD);
	this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, new Float32Array(mesh.vertexArray), this.glVoxelizator.STATIC_DRAW);
	this.textureBuffer_QUAD = this.glVoxelizator.createBuffer();
	this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, this.textureBuffer_QUAD);
	this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, new Float32Array(mesh.textureArray), this.glVoxelizator.STATIC_DRAW);
	this.indexBuffer_QUAD = this.glVoxelizator.createBuffer();
	this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, this.indexBuffer_QUAD);
	this.glVoxelizator.bufferData(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indexArray), this.glVoxelizator.STATIC_DRAW);
	
	
	var sv = this.precision+
			'attribute vec3 aVertexPosition;\n'+  
			'attribute vec3 aVertexNormal;\n'+
			'attribute vec3 aTextureCoord;\n'+
			'attribute float aTextureUnitCoord;\n'+
			
			'uniform mat4 uPMatrix;\n'+
			'uniform mat4 u_cameraWMatrix;\n'+
			'uniform mat4 u_nodeWMatrix;\n'+
			'uniform vec3 u_nodeVScale;\n'+
			
			'uniform int uCurrentOffset;\n'+
			'uniform float uGridsize;\n'+
			
			'varying vec3 vVertexNormal;\n'+
			'varying vec3 vTextureCoord;\n'+
			'varying float vTextureUnit;\n'+
			
			'void main(void) {\n'+
				'vec3 vp = vec3(aVertexPosition.x*u_nodeVScale.x, aVertexPosition.y*u_nodeVScale.y, aVertexPosition.z*u_nodeVScale.z);\n'+
				'vec3 vertexPositionFlipX = vp*vec3(1.0,1.0,1.0);'+
				'vec4 vPosition = uPMatrix*u_cameraWMatrix*u_nodeWMatrix*vec4(vertexPositionFlipX,1.0);'+  
				'vec3 verP; float doffset = 0.02*uGridsize*vPosition.z;'+       
				'if(uCurrentOffset == 0) verP = vec3(vertexPositionFlipX)+(vec3(	doffset,	0.0,	doffset));'+  
				'if(uCurrentOffset == 1) verP = vec3(vertexPositionFlipX)+(vec3(	-doffset,	0.0,	-doffset));'+  
				'if(uCurrentOffset == 2) verP = vec3(vertexPositionFlipX)+(vec3(	-doffset,	0.0,	doffset));'+  
				'if(uCurrentOffset == 3) verP = vec3(vertexPositionFlipX)+(vec3(	doffset,	0.0,	-doffset));'+  
				
				'if(uCurrentOffset == 4) verP = vec3(vertexPositionFlipX)+(vec3(	0.0,		0.0,	doffset));'+  
				'if(uCurrentOffset == 5) verP = vec3(vertexPositionFlipX)+(vec3(	0.0,		0.0,	-doffset));'+  
				'if(uCurrentOffset == 6) verP = vec3(vertexPositionFlipX)+(vec3(	doffset,	0.0,	0.0));'+  
				'if(uCurrentOffset == 7) verP = vec3(vertexPositionFlipX)+(vec3(	-doffset,	0.0,	0.0));'+  
				'gl_Position = uPMatrix*u_cameraWMatrix*u_nodeWMatrix*vec4(verP,1.0);\n'+  
				
				'vVertexNormal = aVertexNormal;\n'+
				'vTextureCoord = aTextureCoord;\n'+
				'vTextureUnit = aTextureUnitCoord;\n'+
			'}';
	var sf = this.precision+
			'uniform sampler2D objectTexturesKd['+this._sec.stormGLContext.MAX_TEXTURESKD+'];\n\n\n'+
			
			'uniform int uTypeFillMode;\n'+
			'uniform int uFillModePos;\n'+
			'uniform int uCurrentHeight;\n'+
			
			'varying vec3 vVertexNormal;\n'+
			'varying vec3 vTextureCoord;\n'+
			'varying float vTextureUnit;\n'+
			
			this._sec.utils.packGLSLFunctionString()+
			
			'void main(void) {\n'+// RGB=COLOR, ALPHA=CELL BIT
				
				'if(uTypeFillMode == 0) {'+ // fill with albedo
					'vec4 textureColor;'+
					'float texUnit = vTextureUnit;'+      
					'if(texUnit &lt; 0.1 ) {';
					for(var n = 0, fn = this._sec.stormGLContext.MAX_TEXTURESKD; n &lt; fn; n++) {
					sf += ''+
						'textureColor = texture2D(objectTexturesKd['+n+'], vec2(vTextureCoord.s, vTextureCoord.t));\n';
					if(n &lt; this._sec.stormGLContext.MAX_TEXTURESKD-1) sf += '} else if(texUnit &lt; '+(n+1)+'.1) {';
					}
					sf += ''+
					'} else {'+
						'textureColor = texture2D(objectTexturesKd[0], vec2(vTextureCoord.s, vTextureCoord.t));\n'+ 
					'}'+	
					
					'gl_FragColor = vec4(textureColor.rgb, 1.0);\n'+
				'} else if(uTypeFillMode == 1) {'+ // fill with position
					'float gridSize = float('+this.size+');'+
					'int maxLevelCells = '+this.resolution+';'+
					'float cs = gridSize/float(maxLevelCells);\n'+ // cell size
					'float chs = cs/2.0;\n'+
					
					'vec3 p = vec3(0.0,0.0,0.0)+vec3(-(gridSize/2.0), -(gridSize/2.0), -(gridSize/2.0));\n'+ // init position
					'float ccX = gl_FragCoord.x;'+
					'int ccY = uCurrentHeight;'+
					'float ccZ = float(maxLevelCells)-gl_FragCoord.y;'+ 		 			
					'p = p+vec3(cs*ccX, cs*float(ccY), cs*ccZ);\n'+
					'p = p+vec3(cs, cs, cs);\n'+
					
					'if(uFillModePos == 0) {'+ // posX
						'gl_FragColor = pack((p.x+(gridSize/2.0))/gridSize);\n'+
					'} else if(uFillModePos == 1) {'+ // posY
						'gl_FragColor = pack((p.y+(gridSize/2.0))/gridSize);\n'+
					'} else {'+ // posZ
						'gl_FragColor = pack((p.z+(gridSize/2.0))/gridSize);\n'+
					'}'+
				'} else if(uTypeFillMode == 2) {'+ // fill with normal
					'gl_FragColor = vec4((vVertexNormal.r+1.0)/2.0,(vVertexNormal.g+1.0)/2.0,(vVertexNormal.b+1.0)/2.0, 1.0);\n'+
				'}'+
			'}';
	this.shader_Voxelizator = this.glVoxelizator.createProgram();   
	this._sec.stormGLContext.createShader(this.glVoxelizator, "VOXELIZATOR", sv, sf, this.shader_Voxelizator);
	this.pointers_VoxelizatorMaker();
};
/** @private */
StormVoxelizator.prototype.pointers_VoxelizatorMaker = function() {	
	this.u_Voxelizator_PMatrix = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uPMatrix");
	this.u_Voxelizator_cameraWMatrix = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "u_cameraWMatrix");
	this.u_Voxelizator_nodeWMatrix = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "u_nodeWMatrix");
	this.u_Voxelizator_nodeVScale = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "u_nodeVScale");
	
	this.samplers_Voxelizator_objectTexturesKd = [];
	for(var n = 0; n &lt; this._sec.stormGLContext.MAX_TEXTURESKD; n++) {
		this.samplers_Voxelizator_objectTexturesKd[n] = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "objectTexturesKd["+n+"]");
	}
	
	this.u_Voxelizator_gridsize = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uGridsize");
	this.attr_Voxelizator_currentOffset = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uCurrentOffset");
	this.attr_Voxelizator_currentHeight = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uCurrentHeight");
	this.attr_Voxelizator_typeFillMode = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uTypeFillMode");
	this.attr_Voxelizator_fillModePos = this.glVoxelizator.getUniformLocation(this.shader_Voxelizator, "uFillModePos");
	
	this.attr_Voxelizator_pos = this.glVoxelizator.getAttribLocation(this.shader_Voxelizator, "aVertexPosition");
	this.attr_Voxelizator_nor = this.glVoxelizator.getAttribLocation(this.shader_Voxelizator, "aVertexNormal");
	this.attr_Voxelizator_tex = this.glVoxelizator.getAttribLocation(this.shader_Voxelizator, "aTextureCoord");
	this.attr_Voxelizator_texUnit = this.glVoxelizator.getAttribLocation(this.shader_Voxelizator, "aTextureUnitCoord");
};
/**
* Generate the voxelizator from the current scene.
* @param	{Object} jsonIn
* 	@param {Float} [jsonIn.size=2.1] Grid size.
* 	@param {Int} [jsonIn.resolution=32] Grid resolution.
* 	@param {Array&lt;String>} [jsonIn.fillmode=["albedo"]] Modes of data fill. "albedo"|"position"|"normal"
* 	@param {Function} [jsonIn.ongenerate] On generate event.
*/
StormVoxelizator.prototype.generateFromScene = function(jsonIn) { 
	this._sec.setStatus({id:'voxelizator', str:'Performing voxelization...'});
	var _this = this;
	setTimeout(function(){
		_this.generateFromSceneNow(jsonIn);
	},30);
};
/** @private */
StormVoxelizator.prototype.generateFromSceneNow = function(jsonIn) { 	
	this.ongeneratefunction = jsonIn.ongenerate;
	
	this.CLGL_Voxels = new WebCLGL(this._sec.stormGLContext.gl);  
	
	this.size = (jsonIn.size != undefined) ? jsonIn.size: 2.1; 
	this.resolution = (jsonIn.resolution != undefined) ? jsonIn.resolution: 32;
	this.cs = this.size/this.resolution;
	this.chs = this.cs/2.0;
	this.wh = Math.ceil(Math.sqrt(this.resolution*this.resolution*this.resolution));
	
	
	
	this.initShader_VoxelizatorMaker();
	
	var nodes = this._sec.nodes;
	this.BOS = [];
	this.MATS = [];
	for(var n = 0, f = nodes.length; n &lt; f; n++) {
		if(nodes[n].visibleOnContext == true &amp;&amp; nodes[n].objectType == 'node') { 
		
			for(var mu = 0, fmu = nodes[n].materialUnits.length; mu &lt; fmu; mu++) { 
				this.MATS[mu] = new StormMaterial(this._sec);
				this.glVoxelizator.pixelStorei(this.glVoxelizator.UNPACK_FLIP_Y_WEBGL, false);      	 
				this.glVoxelizator.pixelStorei(this.glVoxelizator.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
				this.MATS[mu].textureObjectKd.items[0].textureData = this.glVoxelizator.createTexture();
				this.glVoxelizator.bindTexture(this.glVoxelizator.TEXTURE_2D, this.MATS[mu].textureObjectKd.items[0].textureData); 
				var ar = nodes[n].materialUnits[mu].textureObjectKd.items[0].inData;
				this.glVoxelizator.texImage2D(this.glVoxelizator.TEXTURE_2D, 0, this.glVoxelizator.RGBA,
												nodes[n].materialUnits[mu].textureObjectKd.items[0].W,
												nodes[n].materialUnits[mu].textureObjectKd.items[0].H,
												0, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE,
												new Uint8Array(ar));
				this.glVoxelizator.texParameteri(this.glVoxelizator.TEXTURE_2D, this.glVoxelizator.TEXTURE_MAG_FILTER, this.glVoxelizator.NEAREST);
				this.glVoxelizator.texParameteri(this.glVoxelizator.TEXTURE_2D, this.glVoxelizator.TEXTURE_MIN_FILTER, this.glVoxelizator.NEAREST);
				this.glVoxelizator.texParameteri(this.glVoxelizator.TEXTURE_2D, this.glVoxelizator.TEXTURE_WRAP_S, this.glVoxelizator.CLAMP_TO_EDGE);
				this.glVoxelizator.texParameteri(this.glVoxelizator.TEXTURE_2D, this.glVoxelizator.TEXTURE_WRAP_T, this.glVoxelizator.CLAMP_TO_EDGE);
			}
				
			for(var B = 0, fB = nodes[n].buffersObjects.length; B &lt; fB; B++) { 
				BO = nodes[n].buffersObjects[B];
				
				var NEWBO = {};
				NEWBO.drawElementsMode = BO.drawElementsMode;
				NEWBO.node = nodes[n];
				
				NEWBO.nodeMeshVertexBuffer = this.glVoxelizator.createBuffer();
				this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, NEWBO.nodeMeshVertexBuffer);
				this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshVertexArray, this.glVoxelizator.STATIC_DRAW);
				NEWBO.nodeMeshVertexBufferItemSize = BO.nodeMeshVertexBufferItemSize;
				NEWBO.nodeMeshVertexBufferNumItems = BO.nodeMeshVertexBufferNumItems;
				
				if(BO.nodeMeshTextureArray != undefined) {
					NEWBO.nodeMeshTextureBuffer = this.glVoxelizator.createBuffer();
					this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, NEWBO.nodeMeshTextureBuffer);
					this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshTextureArray, this.glVoxelizator.STATIC_DRAW);
					NEWBO.nodeMeshTextureBufferItemSize = BO.nodeMeshTextureBufferItemSize;
					NEWBO.nodeMeshTextureBufferNumItems = BO.nodeMeshTextureBufferNumItems;
				}
				
				if(BO.nodeMeshTextureUnitArray != undefined) {
					NEWBO.nodeMeshTextureUnitBuffer = this.glVoxelizator.createBuffer();
					this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, NEWBO.nodeMeshTextureUnitBuffer);
					this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshTextureUnitArray, this.glVoxelizator.STATIC_DRAW);
					NEWBO.nodeMeshTextureUnitBufferItemSize = BO.nodeMeshTextureUnitBufferItemSize;
					NEWBO.nodeMeshTextureUnitBufferNumItems = BO.nodeMeshTextureUnitBufferNumItems;
				}
				
				if(BO.nodeMeshNormalArray != undefined) {
					NEWBO.nodeMeshNormalBuffer = this.glVoxelizator.createBuffer();
					this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, NEWBO.nodeMeshNormalBuffer);
					this.glVoxelizator.bufferData(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshNormalArray, this.glVoxelizator.STATIC_DRAW);
					NEWBO.nodeMeshNormalBufferItemSize = BO.nodeMeshNormalBufferItemSize;
					NEWBO.nodeMeshNormalBufferNumItems = BO.nodeMeshNormalBufferNumItems;
				}
				
				if(BO.nodeMeshIndexArray != undefined) {
					NEWBO.nodeMeshIndexBuffer = this.glVoxelizator.createBuffer();
					this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, NEWBO.nodeMeshIndexBuffer);
					this.glVoxelizator.bufferData(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexArray, this.glVoxelizator.STATIC_DRAW);
					NEWBO.nodeMeshIndexBufferItemSize = BO.nodeMeshIndexBufferItemSize;
					NEWBO.nodeMeshIndexBufferNumItems = BO.nodeMeshIndexBufferNumItems;
				}
				this.BOS.push(NEWBO);
			}
			
		}
	}
	
	this.glVoxelizator.clearColor(0.0,0.0,0.0,0.0); 
	//this.glVoxelizator.clearDepth(1.0);
	//this.glVoxelizator.enable(this.glVoxelizator.DEPTH_TEST);
	//this.glVoxelizator.depthFunc(this.glVoxelizator.LEQUAL);  
	this.glVoxelizator.bindFramebuffer(this.glVoxelizator.FRAMEBUFFER, null);
	this.glVoxelizator.useProgram(this.shader_Voxelizator); 	 
	this.glVoxelizator.viewport(0, 0, this.resolution, this.resolution);
	
	var fovy = this.size/2;
	var Mprojection = $M16().setOrthographicProjection(-fovy, fovy, -fovy, fovy, 0.0, this.cs);      
	/*var fovy = 179.1;
	var Mprojection = $M16().setPerspectiveProjection(fovy, this.resolution/this.resolution, 0.000001, this.cs+0.000002);  */ 	
	this.glVoxelizator.uniformMatrix4fv(this.u_Voxelizator_PMatrix, false, Mprojection.transpose().e); 
	
	this.glVoxelizator.uniform1f(this.u_Voxelizator_gridsize, this.size);
	
	
	
	this.arr_VoxelsColor = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionX = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionY = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionZ = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsNormal = new Uint8Array(this.wh*this.wh*4); 
	
	
	if(jsonIn.fillmode == undefined) {
		this.typeFillMode = "albedo";
		this.renderVoxelHeight(0);  
	} else {
		for(var n = 0; n &lt; jsonIn.fillmode.length; n++) {
			this.typeFillMode = jsonIn.fillmode[n];
			this.renderVoxelHeight(0);  
		}
	}
	if(this.ongeneratefunction != undefined) this.ongeneratefunction();
	this._sec.setStatus({id:'voxelizator', str:''});
};
/** @private  */
StormVoxelizator.prototype.renderVoxelHeight = function(currentHeight) { 
	// CAMERA CURRENT HEIGHT POSITION
	var p = $V3([0.0,0.0,0.0]).add($V3([0.0, -(this.size/2.0), 0.0])); // init position  
	p = p.add($V3([0.0, this.cs, 0.0]));  
	p = p.add($V3([0.0, this.cs*(currentHeight), 0.0]));  
	var pc = p.add($V3([0.0,-1.0,0.0]));
	/*var Mpos = $M16().setPosition(p);
	var rot = 0; 
	var MrotX = $M16().setRotationX(this._sec.utils.degToRad(-90+rot)); 
	var MrotZ = $M16().setRotationZ(this._sec.utils.degToRad(rot));*/ 
	var Mcamera = $M16().makeLookAt(p.e[0], p.e[1], p.e[2],
									pc.e[0], pc.e[1], pc.e[2], 
									0.0,0.0,1.0);	 
	var MrotY = $M16().setRotationY(this._sec.utils.degToRad(180));  
	var Mcamera = Mcamera.x(MrotY);
	this.glVoxelizator.uniformMatrix4fv(this.u_Voxelizator_cameraWMatrix, false, Mcamera.transpose().e);   
	
	this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentHeight, currentHeight);
	
	var idx3d = (currentHeight*(this.resolution*this.resolution))*4;  
	var num = idx3d/this.wh;
	var col = this._sec.utils.fract(num)*this.wh; 
	var row = Math.floor(num);
	
	var fm;
	if(this.typeFillMode == "albedo") fm = 0;
	if(this.typeFillMode == "position") fm = 1;
	if(this.typeFillMode == "normal") fm = 2;
	this.glVoxelizator.uniform1i(this.attr_Voxelizator_typeFillMode, fm);
	
	// RENDER THE CURRENT HEIGHT &amp; FILL THE 3D TEXTURE AT CORRESPONDING ID IN arrVoxel
	if(this.typeFillMode == "albedo") {
		this.renderVoxelHeightPass();
		var heightImageResult = new Uint8Array(this.resolution*this.resolution*4);
		this.glVoxelizator.readPixels(0, 0, this.resolution, this.resolution, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE, heightImageResult);
		this.arr_VoxelsColor.set(heightImageResult, idx3d);
	} else if(this.typeFillMode == "position") {
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_fillModePos, 0); // X
		this.renderVoxelHeightPass();
		var heightImageResult = new Uint8Array(this.resolution*this.resolution*4);
		this.glVoxelizator.readPixels(0, 0, this.resolution, this.resolution, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE, heightImageResult);
		this.arr_VoxelsPositionX.set(heightImageResult, idx3d);
		
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_fillModePos, 1); // Y
		this.renderVoxelHeightPass();
		var heightImageResult = new Uint8Array(this.resolution*this.resolution*4);
		this.glVoxelizator.readPixels(0, 0, this.resolution, this.resolution, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE, heightImageResult);
		this.arr_VoxelsPositionY.set(heightImageResult, idx3d);
		
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_fillModePos, 2); // Z
		this.renderVoxelHeightPass();
		var heightImageResult = new Uint8Array(this.resolution*this.resolution*4);
		this.glVoxelizator.readPixels(0, 0, this.resolution, this.resolution, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE, heightImageResult);
		this.arr_VoxelsPositionZ.set(heightImageResult, idx3d);
	} else if(this.typeFillMode == "normal") {
		this.renderVoxelHeightPass();
		var heightImageResult = new Uint8Array(this.resolution*this.resolution*4);
		this.glVoxelizator.readPixels(0, 0, this.resolution, this.resolution, this.glVoxelizator.RGBA, this.glVoxelizator.UNSIGNED_BYTE, heightImageResult);
		this.arr_VoxelsNormal.set(heightImageResult, idx3d);
	}
	
	
	
	
	
	currentHeight++;
	if(currentHeight &lt; this.resolution) {    
		var _this = this;
		//setTimeout(function() { 
						this.renderVoxelHeight(currentHeight);
					//},100);
	} else {
		if(this.typeFillMode == "albedo") {
			this.setVoxels({'image':this.arr_VoxelsColor, 'wh':this.wh});
		} else if(this.typeFillMode == "position") {
			this.typeFillMode = "positionX";
			this.setVoxels({'image':this.arr_VoxelsPositionX, 'posChannel':0, 'wh':this.wh});
			this.typeFillMode = "positionY";
			this.setVoxels({'image':this.arr_VoxelsPositionY, 'posChannel':1, 'wh':this.wh});
			this.typeFillMode = "positionZ";
			this.setVoxels({'image':this.arr_VoxelsPositionZ, 'posChannel':2, 'wh':this.wh});
		} else if(this.typeFillMode == "normal") {
			this.setVoxels({'image':this.arr_VoxelsNormal, 'wh':this.wh});
		}
	}
};
/** @private */
StormVoxelizator.prototype.renderVoxelHeightPass = function() { 
	this.glVoxelizator.clear(this.glVoxelizator.COLOR_BUFFER_BIT | this.glVoxelizator.DEPTH_BUFFER_BIT);   
	
	for(var B = 0, fB = this.BOS.length; B &lt; fB; B++) { 
		BO = this.BOS[B];
		this.glVoxelizator.uniformMatrix4fv(this.u_Voxelizator_nodeWMatrix, false, BO.node.MPOS.x(BO.node.MROTXYZ).transpose().e);
		this.glVoxelizator.uniform3f(this.u_Voxelizator_nodeVScale, BO.node.VSCALE.e[0], BO.node.VSCALE.e[1], BO.node.VSCALE.e[2]);   
		
		var next = 0; 
		for(var n = 0; (n &lt; this.MATS.length); n++) {
			eval("this.glVoxelizator.activeTexture(this.glVoxelizator.TEXTURE"+(next)+");")
			this.glVoxelizator.bindTexture(this.glVoxelizator.TEXTURE_2D, this.MATS[n].textureObjectKd.items[0].textureData);    
			this.glVoxelizator.uniform1i(this.samplers_Voxelizator_objectTexturesKd[n], next);
			next++;
		}
	
		this.glVoxelizator.enableVertexAttribArray(this.attr_Voxelizator_pos);
		this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshVertexBuffer);
		this.glVoxelizator.vertexAttribPointer(this.attr_Voxelizator_pos, 3, this.glVoxelizator.FLOAT, false, 0, 0);
		
		this.glVoxelizator.enableVertexAttribArray(this.attr_Voxelizator_nor);
		this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshNormalBuffer);
		this.glVoxelizator.vertexAttribPointer(this.attr_Voxelizator_nor, 3, this.glVoxelizator.FLOAT, false, 0, 0);
		
		this.glVoxelizator.enableVertexAttribArray(this.attr_Voxelizator_tex);
		this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshTextureBuffer);
		this.glVoxelizator.vertexAttribPointer(this.attr_Voxelizator_tex, 3, this.glVoxelizator.FLOAT, false, 0, 0);
		
		this.glVoxelizator.enableVertexAttribArray(this.attr_Voxelizator_texUnit);
		this.glVoxelizator.bindBuffer(this.glVoxelizator.ARRAY_BUFFER, BO.nodeMeshTextureUnitBuffer);
		this.glVoxelizator.vertexAttribPointer(this.attr_Voxelizator_texUnit, 1, this.glVoxelizator.FLOAT, false, 0, 0);
		
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 0);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 1);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 2);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 3);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	 
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 4);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 5);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 6);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
		this.glVoxelizator.uniform1i(this.attr_Voxelizator_currentOffset, 7);
		if(BO.nodeMeshIndexBuffer != undefined) {
			this.glVoxelizator.bindBuffer(this.glVoxelizator.ELEMENT_ARRAY_BUFFER, BO.nodeMeshIndexBuffer);
			this.glVoxelizator.drawElements(BO.drawElementsMode, BO.nodeMeshIndexBufferNumItems, this.glVoxelizator.UNSIGNED_SHORT, 0);
		} else {
			this.glVoxelizator.drawArrays(BO.drawElementsMode, 0, BO.nodeMeshVertexBufferNumItems); 
		}  	
	}
};  
/**
* get3DImageElement
* 	@param {String} [fillmode="albedo"] Mode of data fill to get. "albedo"|"positionX"|"positionY"|"positionZ"|"normal"
* @returns {HTMLImageElement}
*/
StormVoxelizator.prototype.get3DImageElement = function(fillmode) { 
	if(fillmode == undefined || fillmode == "albedo") {
		if(this.image3D_VoxelsColor != undefined)
			return this.image3D_VoxelsColor; 
		else return false;
	} else if(fillmode == "positionX") {
		if(this.image3D_VoxelsPositionX != undefined)
			return this.image3D_VoxelsPositionX; 
		else return false;
	} else if(fillmode == "positionY") {
		if(this.image3D_VoxelsPositionY != undefined)
			return this.image3D_VoxelsPositionY; 
		else return false;
	} else if(fillmode == "positionZ") {
		if(this.image3D_VoxelsPositionZ != undefined)
			return this.image3D_VoxelsPositionZ; 
		else return false;
	} else if(fillmode == "normal") {
		if(this.image3D_VoxelsNormal != undefined)
			return this.image3D_VoxelsNormal; 
		else return false;
	}
	
};

  

/**
* Generate the voxelizator from 3DImageElement
* @returns {StormVoxelizator}
* @param	{Object} jsonIn
* 	@param {Float} jsonIn.size Grid size.
* 	@param {Int} jsonIn.resolution Grid resolution. (No 3Dtexture resolution)
* 	@param {Array&lt;String>} [jsonIn.fillmode=["albedo"]] Modes of data fill. "albedo"|"positionX"|"positionY"|"positionZ"|"normal"
* 	@param {Array&lt;String|HTMLImageElement|Array&lt;String>>} jsonIn.image 3Dtexture urls array or HTMLImageElements array or array of url subarrays for each slice of a 3Dtexture.
* 	@param {Function} [jsonIn.ongenerate] On generate event.
*/
StormVoxelizator.prototype.generateFrom3DImageElement = function(jsonIn) {  
	this.ongeneratefunction = jsonIn.ongenerate;
	
	this.CLGL_Voxels = new WebCLGL(this._sec.stormGLContext.gl);  
	
	this.size = (jsonIn.size != undefined) ? jsonIn.size: 2.1; 
	this.resolution = jsonIn.resolution;  
	this.cs = this.size/this.resolution;
	this.chs = this.cs/2.0;
	this.wh = Math.ceil(Math.sqrt(this.resolution*this.resolution*this.resolution)); // 64*64*64=262144 //sqrt(64*64*64)=512 //512*512=262144
	
	this.arr_VoxelsColor = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionX = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionY = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsPositionZ = new Uint8Array(this.wh*this.wh*4); 
	this.arr_VoxelsNormal = new Uint8Array(this.wh*this.wh*4); 
	
	
	if(jsonIn.fillmode == undefined) {
		this.typeFillMode = "albedo";
		
		this.setVoxels({'image':jsonIn.image[0], 'wh':this.wh, 'ongenerate': this.ongeneratefunction});
	} else {	
		for(var n = 0; n &lt; jsonIn.fillmode.length; n++) {
			this.typeFillMode = jsonIn.fillmode[n];
			
			if(jsonIn.image[n].constructor === Array) { // array of urls
				for(var nb=0; nb &lt; jsonIn.image[n].length; nb++) {
					var idx3d = (nb*(this.resolution*this.resolution))*4; 
					
					var imageElement = new Image();
					imageElement.voxelizator = this;				
					imageElement.onload = (function(n, nb, idx3d, imageElement) {		
						if(this.typeFillMode == "albedo") {
							this.arr_VoxelsColor.set(this._sec.utils.getUint8ArrayFromHTMLImageElement(imageElement), idx3d);							
							if(nb == jsonIn.image[n].length-1) {
								this.setVoxels({'image':this.arr_VoxelsColor, 'wh':this.wh});
								
								if(this.ongeneratefunction != undefined &amp;&amp; n == (jsonIn.fillmode.length-1)) {
									this.ongeneratefunction(this);
								}
							}
						} else if(this.typeFillMode == "positionX") {
							this.arr_VoxelsPositionX.set(this._sec.utils.getUint8ArrayFromHTMLImageElement(imageElement), idx3d);
							if(nb == jsonIn.image[n].length-1) {
								this.setVoxels({'image':this.arr_VoxelsPositionX, 'posChannel':0, 'wh':this.wh});
								
								if(this.ongeneratefunction != undefined &amp;&amp; n == (jsonIn.fillmode.length-1)) {
									this.ongeneratefunction(this);
								}
							}
						} else if(this.typeFillMode == "positionY") {
							this.arr_VoxelsPositionY.set(this._sec.utils.getUint8ArrayFromHTMLImageElement(imageElement), idx3d);
							if(nb == jsonIn.image[n].length-1) {
								this.setVoxels({'image':this.arr_VoxelsPositionY, 'posChannel':1, 'wh':this.wh});
								
								if(this.ongeneratefunction != undefined &amp;&amp; n == (jsonIn.fillmode.length-1)) {
									this.ongeneratefunction(this);
								}
							}
						} else if(this.typeFillMode == "positionZ") {
							this.arr_VoxelsPositionZ.set(this._sec.utils.getUint8ArrayFromHTMLImageElement(imageElement), idx3d);
							if(nb == jsonIn.image[n].length-1) {
								this.setVoxels({'image':this.arr_VoxelsPositionZ, 'posChannel':2, 'wh':this.wh});
								
								if(this.ongeneratefunction != undefined &amp;&amp; n == (jsonIn.fillmode.length-1)) {
									this.ongeneratefunction(this);
								}
							}
						} else if(this.typeFillMode == "normal"){
							this.arr_VoxelsNormal.set(this._sec.utils.getUint8ArrayFromHTMLImageElement(imageElement), idx3d);
							if(nb == jsonIn.image[n].length-1) {
								this.setVoxels({'image':this.arr_VoxelsNormal, 'wh':this.wh});
								
								if(this.ongeneratefunction != undefined &amp;&amp; n == (jsonIn.fillmode.length-1)) {
									this.ongeneratefunction(this);
								}
							}
						}						
					}).bind(this, n, nb, idx3d, imageElement);
					imageElement.src = jsonIn.image[n][nb];
				}
			} else {
				if(n == (jsonIn.fillmode.length-1)) {
					this.setVoxels({'image':jsonIn.image[n], 'wh':this.wh, 'ongenerate': this.ongeneratefunction});
				} else {
					this.setVoxels({'image':jsonIn.image[n], 'wh':this.wh});
				}
			}
		}		
	}
	
};









/** @private */
StormVoxelizator.prototype.setVoxels = function(jsonIn) { 
	if(jsonIn.image instanceof Uint8Array || jsonIn.image instanceof HTMLImageElement) {
		var buffer = this.CLGL_Voxels.createBuffer(jsonIn.wh*jsonIn.wh, 'FLOAT4', this.size/1.9);
		this.CLGL_Voxels.enqueueWriteBuffer(buffer, jsonIn.image);
		
		if(this.typeFillMode == "albedo") {
			this.clglBuff_VoxelsColor = buffer; 
			var canvas = (jsonIn.image instanceof Uint8Array) ?
				this._sec.utils.getCanvasFromUint8Array(jsonIn.image,jsonIn.wh,jsonIn.wh) :
				this._sec.utils.getCanvasFromUint8Array(this._sec.utils.getUint8ArrayFromHTMLImageElement(jsonIn.image),jsonIn.wh,jsonIn.wh);
			this.image3D_VoxelsColor = this._sec.utils.getImageFromCanvas(canvas);
		} else if(this.typeFillMode == "positionX") {
			this.clglBuff_VoxelsPositionX = buffer; 
			var canvas = (jsonIn.image instanceof Uint8Array) ?
				this._sec.utils.getCanvasFromUint8Array(jsonIn.image,jsonIn.wh,jsonIn.wh) :
				this._sec.utils.getCanvasFromUint8Array(this._sec.utils.getUint8ArrayFromHTMLImageElement(jsonIn.image),jsonIn.wh,jsonIn.wh);
			this.image3D_VoxelsPositionX = this._sec.utils.getImageFromCanvas(canvas);
		} else if(this.typeFillMode == "positionY") {
			this.clglBuff_VoxelsPositionY = buffer; 
			var canvas = (jsonIn.image instanceof Uint8Array) ?
				this._sec.utils.getCanvasFromUint8Array(jsonIn.image,jsonIn.wh,jsonIn.wh) :
				this._sec.utils.getCanvasFromUint8Array(this._sec.utils.getUint8ArrayFromHTMLImageElement(jsonIn.image),jsonIn.wh,jsonIn.wh);
			this.image3D_VoxelsPositionY = this._sec.utils.getImageFromCanvas(canvas);
		} else if(this.typeFillMode == "positionZ") {
			this.clglBuff_VoxelsPositionZ = buffer; 
			var canvas = (jsonIn.image instanceof Uint8Array) ?
				this._sec.utils.getCanvasFromUint8Array(jsonIn.image,jsonIn.wh,jsonIn.wh) :
				this._sec.utils.getCanvasFromUint8Array(this._sec.utils.getUint8ArrayFromHTMLImageElement(jsonIn.image),jsonIn.wh,jsonIn.wh);
			this.image3D_VoxelsPositionZ = this._sec.utils.getImageFromCanvas(canvas);
		} else if(this.typeFillMode == "normal") {
			this.clglBuff_VoxelsNormal = buffer; 
			var canvas = (jsonIn.image instanceof Uint8Array) ?
				this._sec.utils.getCanvasFromUint8Array(jsonIn.image,jsonIn.wh,jsonIn.wh) :
				this._sec.utils.getCanvasFromUint8Array(this._sec.utils.getUint8ArrayFromHTMLImageElement(jsonIn.image),jsonIn.wh,jsonIn.wh);
			this.image3D_VoxelsNormal = this._sec.utils.getImageFromCanvas(canvas);
		}
	} else { 
		var imageElement = new Image();
		imageElement.voxelizator = this;
		imageElement.onload = (function(ongenerate, imageElement) {
			var buffer = this.CLGL_Voxels.createBuffer(imageElement.width*imageElement.height, 'FLOAT4', this.size/1.9);      
			this.CLGL_Voxels.enqueueWriteBuffer(buffer, imageElement);  
			
			if(this.typeFillMode == "albedo") {
				this.clglBuff_VoxelsColor = buffer; 
				this.image3D_VoxelsColor = imageElement;
			} else if(this.typeFillMode == "positionX") {
				this.clglBuff_VoxelsPositionX = buffer; 
				this.image3D_VoxelsPositionX = imageElement;
			} else if(this.typeFillMode == "positionY") {
				this.clglBuff_VoxelsPositionY = buffer; 
				this.image3D_VoxelsPositionY = imageElement;
			} else if(this.typeFillMode == "positionZ") {
				this.clglBuff_VoxelsPositionZ = buffer; 
				this.image3D_VoxelsPositionZ = imageElement;
			} else if(this.typeFillMode == "normal"){
				this.clglBuff_VoxelsNormal = buffer;
				this.image3D_VoxelsNormal = imageElement;
			}
			
			if(ongenerate != undefined) ongenerate(this);
		}).bind(this, jsonIn.ongenerate, imageElement);
		imageElement.src = jsonIn.image;
	}
};






 /** @private  */
StormVoxelizator.prototype.worldToVoxel = function(world) {
	var gl = $V3([-(this.size/2.0), -(this.size/2.0), -(this.size/2.0)]);
	var _r = $V3([this.size, this.size, this.size]);
	var _rRes = $V3([this.resolution, this.resolution, this.resolution]);
	var _len = $V3([_r.e[0]/_rRes.e[0], _r.e[1]/_rRes.e[1], _r.e[2]/_rRes.e[2]]);
	
	var ijk = (world.subtract(gl));
	ijk = $V3([ijk.e[0]/_len.e[0], ijk.e[1]/_len.e[1], ijk.e[2]/_len.e[2]]);
	ijk = $V3([Math.floor(ijk.e[0]), Math.floor(ijk.e[1]), Math.floor(ijk.e[2])]); 
	return ijk;
};
/** @private  */
StormVoxelizator.prototype.rayTraversalInitSTR = function() {  
	return ''+
	'const float gridSize = float('+this.size+');\n'+ // grid size  	 
	'float wh = ceil(sqrt(float('+this.resolution+')*float('+this.resolution+')*float('+this.resolution+')));\n'+  	
	'const float cs = gridSize/float('+this.resolution+');\n'+ // cell size 
	'const float chs = cs/2.0;\n'+ // cell size 
	'float texelSize = 1.0/(wh-1.0);\n'+  // 1.0/(wh-1.0)??
	
	// Fast Voxel Traversal Algorithm for Ray Tracing. John Amanatides &amp; Andrew Woo.
	// http://www.cse.chalmers.se/edu/course/TDA361/grid.pdf
	// More info:
	// http://www.researchgate.net/publication/228770849_Ray_tracing_on_GPU/file/79e415105577b914fd.pdf
	// http://www.clockworkcoders.com/oglsl/rt/gpurt3.htm
	// http://www.gamerendering.com/2009/07/20/grid-traversal/
	'const vec3 gl = vec3(-(gridSize/2.0), -(gridSize/2.0), -(gridSize/2.0));\n'+    
	'const vec3 _r = vec3(gridSize, gridSize, gridSize);\n'+
	'const vec3 _rRes = vec3(float('+this.resolution+'), float('+this.resolution+'), float('+this.resolution+'));\n'+
	'const vec3 _len = _r/_rRes;\n'+  
	'vec3 worldToVoxel(vec3 world) {\n'+
		'vec3 ijk = (world - gl) / _len;\n'+ // (1.0-(-1.0)) / (2/64) = 64 
		'ijk = vec3(floor(ijk.x), floor(ijk.y), floor(ijk.z));\n'+
		'return ijk;\n'+
	'}\n'+
	'float voxelToWorldX(float x) {return x * _len.x + gl.x;}\n'+ // 64*(2/64)+(-1.0) = 1.0
	'float voxelToWorldY(float y) {return y * _len.y + gl.y;}\n'+
	'float voxelToWorldZ(float z) {return z * _len.z + gl.z;}\n';
};
/** @private  */
StormVoxelizator.prototype.rayTraversalSTR = function(getVoxelFunctionGLSLStr) {  
	return ''+
	'vec4 rayTraversal(vec3 RayOrigin, vec3 RayDir) {\n'+
		'vec3 voxel = worldToVoxel(RayOrigin);'+   
		'vec3 _dir = normalize(RayDir);'+   
		'vec3 tMax;'+  
		'if(RayDir.x &lt; 0.0) tMax.x = (voxelToWorldX(voxel.x)-RayOrigin.x)/RayDir.x;'+ 	      
		'if(RayDir.x > 0.0) tMax.x = (voxelToWorldX(voxel.x+1.0)-RayOrigin.x)/RayDir.x;'+
		'if(RayDir.y &lt; 0.0) tMax.y = (voxelToWorldY(voxel.y)-RayOrigin.y)/RayDir.y;'+
		'if(RayDir.y &lt; 0.0) tMax.y = (voxelToWorldY(voxel.y+1.0)-RayOrigin.y)/RayDir.y;'+
		'if(RayDir.z &lt; 0.0) tMax.z = (voxelToWorldZ(voxel.z)-RayOrigin.z)/RayDir.z;'+
		'if(RayDir.z &lt; 0.0) tMax.z = (voxelToWorldZ(voxel.z+1.0)-RayOrigin.z)/RayDir.z;'+
		 
		'float tDeltaX = _r.x/abs(RayDir.x);'+// hasta qué punto se debe avanzar en la dirección del rayo antes de que nos encontramos con un nuevo voxel en la dirección x
		'float tDeltaY = _r.y/abs(RayDir.y);'+
		'float tDeltaZ = _r.z/abs(RayDir.z);'+   

		'float stepX = 1.0; float stepY = 1.0; float stepZ = 1.0;\n'+
		'float outX = _r.x; float outY = _r.y; float outZ = _r.z;\n'+
		'if(RayDir.x &lt; 0.0) {stepX = -1.0; outX = -1.0;}'+
		'if(RayDir.y &lt; 0.0) {stepY = -1.0; outY = -1.0;}'+
		'if(RayDir.z &lt; 0.0) {stepZ = -1.0; outZ = -1.0;}'+ 
			
		'vec4 color = vec4(0.0,0.0,0.0,0.0);\n'+
		'vec4 gv = vec4(0.0,0.0,0.0,0.0);\n'+
		'bool c1; bool c2; bool c3; bool isOut;'+
		'for(int c = 0; c &lt; '+(this.resolution*2)+'; c++) {\n'+      
			'c1 = bool(tMax.x &lt; tMax.y);'+
			'c2 = bool(tMax.x &lt; tMax.z);'+
			'c3 = bool(tMax.y &lt; tMax.z);'+
			'isOut = false;'+
			'if (c1 &amp;&amp; c2) {'+
				'voxel.x += stepX;'+
				'if(voxel.x==outX) isOut=true;'+
				'tMax.x += tDeltaX;'+
			'} else if(( (c1 &amp;&amp; !c2) || (!c1 &amp;&amp; !c3) )) {'+
				'voxel.z += stepZ;'+
				'if(voxel.z==outZ) isOut=true;'+
				'tMax.z += tDeltaZ;'+
			'} else if(!c1 &amp;&amp; c3) {'+
				'voxel.y += stepY;'+
				'if(voxel.y==outY) isOut=true;'+
				'tMax.y += tDeltaY;'+
			'}'+       
			'if(isOut == true) break;\n'+  
			'else {'+
				'if((voxel.x >= 0.0 &amp;&amp; voxel.x &lt;= _rRes.x &amp;&amp; voxel.y >= 0.0 &amp;&amp; voxel.y &lt;= _rRes.y &amp;&amp; voxel.z >= 0.0 &amp;&amp; voxel.z &lt;= _rRes.z)) {;\n'+  
					getVoxelFunctionGLSLStr+ 
				'}'+ 
			'}'+
		'}'+
		'return color;'+
	'}\n';
};</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					StormEngineC 1.2 API DOC
					<br />
					
					
		<span class="copyright">
		2010 Roberto Gonzalez. http://stormcolour.appspot.com
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha2</a>
		on Fri Nov 06 2015 21:30:55 GMT+0100 (CET) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	
	<script>
		$( function () {
			$('#main').localScroll({
				offset: { top: 56 } //offset by the height of your header (give or take a few px, see what works for you)
			});
			$( "dt h4.name" ).each( function () {
				var $this = $( this );
				var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
				var dt = $this.parents( "dt" );
				var children = dt.next( "dd" );

				$this.append( icon ).css( {cursor : "pointer"} );
				$this.addClass( "member-collapsed" ).addClass( "member" );

				children.hide();
				$this.toggle( function () {
					icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
					$this.addClass( "member-open" ).removeClass( "member-collapsed" );
					children.slideDown();
				}, function () {
					icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
					$this.addClass( "member-collapsed" ).removeClass( "member-open" );
					children.slideUp();
				} );
			} );
		} );
	</script>
	

</body>
</html>
